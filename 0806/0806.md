### 2차원 배열
- 2차원 배열
  - 1차원 list를 묶어놓은 list
  - 2차원 이상의 다차원 list는 차원에 따라 index를 선언
  - arr = [[0, 1, 2, 3],[4, 5, ,6, 7]]에서 arr[1][2] = 4
    - 첫번째 대괄호[]는 행을, 두번째 대괄호[]는 열을 의미
- 입력을 2차원 배열에 저장하기
```python
'''
3
1 2 3
4 5 6
7 8 9  # 입력값
'''
N = int(input())
arr = [list(map(int,input().split())) for _ in range(N)]
```
- 0으로 채워진 3X4 배열 만들기
```python
arr = [[0] * 4 for _ in range(3)]
# arr = [[0] * 4] * 3 은 얕은복사가 되므로 사용하지 말것
```
- 배열 순회
  - n X m 배열의 n * m 개의 모든 원소를 빠짐없이 조사하는 방법
```python
for i in range(n):      # 각각의 행마다
    for j in range(m):      # 순회하며 열 각각의 원소를 조사
        f(arr[i][j])  # 필요한 연산 수행
```
  - 행의 합 중 최댓값은?
```python
max_v = 0
for i in range(n)
    check = 0
    for j in range(m):
        check += arr[i][j]
    
    if max_v < check:
        max_v = check
```
  - N X M 배열의 크기와 저장된 값이 주어질 때 합을 구하는 방법
```python
'''
3 4
1 7 2 8
6 2 9 3
5 7 4 2
'''
N, M = map(int, input().split())
arr = [[list(map(int, input().split()))] for _ in range(N)]

s = 0

for i in range(N):
    for j in range(M):
        s += arr[i][j]
```
- 열 우선 순회
```python
for j in range(m):
    for i in range(n):
        f(arr[i][j])
```
- 지그재그 순회
```python
for i in range(n):
    if i % 2 == 0:
        for j in range(m):
            f(arr[i][j])
    else:
        for j in range(m-1, -1, -1):
            f(arr[i][j])
```
```python
for i in range(n):
    for j in range(m):
        f(arr[i][j + (m-1-2*j) * (i%2)])
```

### 델타
- 델타
  - 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
  - 인덱스 (i, j)인 칸의 상하좌우 칸(ni, nj)
  ![델타](델타.png)
```python
di = [0, 1, 0, -1]      # 방향별로 더할 값
dj = [1, 0, -1, 0]

for k in range(0, 4):
    ni = i + di[k]
    nj = j + dj[k]
```
```python
for i in range(N):
    for j in range(N):
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            ni, nj = i+di, j+dj
        ...
```
- 델타 응용
  - NxN 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최댓값
```python
max_v = 0
for i in range(N):
    for j in range(N):
        s = arr[i][j]       # i, j를 중심으로
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:       # 각 방향
            for c in range(1, k+1):     # 거리별
                ni, nj = i+di*c, j+dj*c
                if 0<=ni<N and 0<=nj<N:        # 밖으로 나가지 않도록 설정
                    s += arr[ni][nj]
        if max_v < s:
            max_v = s
```
- 전치 행렬 : 대각선 상의 원소들의 자리를 바꿈
```python
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for i in range(3):
    for j in range(3):
        if i < j:   # 대각선 위쪽이나 아래쪽 중 한번만 변경을 해주면 됨
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```
- 연습문제
  - 5X5 2차원 배열에 25개의 숫자를 저장하고, 대각선 위에 있는 원소들의 합을 구하시오.
```python
s == 0
for i in range(5):
    s += arr[i][i]
    s += arr[i][4-i]

s -= arr[2][2]    # 중복된 원소 제거
```

