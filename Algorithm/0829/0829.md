### 이진트리
- 이진트리 연습
```python
'''
13
1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13
'''

V = int(input())
E = V - 1
arr = list(map(int, input().split()))

left = [0] * (V + 1)  # 부모 번호를 인덱스로 자식 번호 저장
right = [0] * (V + 1)
par = [0] * (v + 1)   # 자식 번호를 인덱스로 부모 번호 저장

def pre_order(T):  # 전위순회
    if T > 0:
        print(T, end = ' ')   # visit(T)
        pre_order(left[T])   # T의 왼쪽을 저장
        pre_order(right[T])

def in_order(T):   # 중위순회
    if T > 0:
        in_order(left[T])
        print(T, end = ' ')
        in_order(right[T])

def post_order(T):   # 후위순회
    if T > 0:
        post_order(left[T])
        post_order(right[T])
        print(T, end = ' ')


for i in range(E):
    p, c = arr[i*2], arr[i*2+1]
    par[c] = p
    if left[p] == 0:
        left[p] = c
    else:
        right[p] = c
        
root = 1
for i in range(1, V+1):
    if par[i] == 0:  # 부모 노드가 없는 경우
        root = i
        break

print(pre_order(root))
```

### 이진 탐색 트리
- 이진 탐색 트리(Binary Search Tree, BST)
  - 탐색 작업을 효율적으로 하기 위한 자료 구조
  - 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음
  - key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 이진 탐색 트리 연산
  - 루트에서 시작
  - 탐색할 키 값 x를 루트 노드의 키 값과 비교
  - 서브트리에 대해서 순환적으로 탐색 연산을 반복

### 힙
- 힙
  - 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위하 만들어진 자료구조
- 최대 힙
  - 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    - 부모노드의 키값 > 자식노드의 키값
  - 루트 노드 : 키값이 가장 큰 노드
- 최소 힙
  - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
    - 부모노드의 키값 < 자식노드의 키값
  - 루트 노드 : 키값이 가장 작은 노드
- 추가 코드
```python
def enq(n):
    global last
    last += 1
    heap[last] = n

    c = last
    p = c // 2   # 완전이진트리 자식->부모 연산
    while p and heap[p] < heap[c]:      # 부모가 있고, 부모 < 자식이면 키값 교환
        heap[p], heap[c] = heap[c], heap[p]
        c = p
        p = c // 2
```
- 삭제 코드
```python
def deq():
    global last
    tmp = heap[1]    # 루 백업
    heap[1] = heap[last]    # 삭제할 노드의 키를 루트에 복사
    last -= 1   # 마지막 노드 삭제
    p = 1   
    c = p * 2   # 왼쪽 자식
    while c <= last:    # 자식이 하나라도 있으면
        if c+1 <= last and heap[c] < heap[c+1]: # 오른쪽 자식이 있고, 오른쪽 자식이 더 크면
            c += 1  # 비교대상을 오른쪽 자식으로 설정
        if heap[p] < heap[c]:   # 자식이 더 크면,
            heap[p], heap[c] = heap[c], heap[p]
            p = c   # 자식을 새로운 부모로
            c = p * 2   # 왼쪽 자식 번호 계산
        else:   # 부모가 더 크면
            break   # 비교를 중단
    return tmp
```
