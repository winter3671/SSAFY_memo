### 알고리즘
- 좋은 알고리즘이란?
  - 정확성(얼마나 정확하게 동작하는가)
  - 작업량(얼마나 적은 연산으로 원하는 결과를 얻어내는가)
  - 메모리 사용량(얼마나 적은 메모리를 사용하는가)
  - 단순성(얼마나 단순한가)
  - 최적성(더 이상 개선할 여지없이 최적화되었는가)
- 알고리즘 성능 비교 예시
  - 1부터 100까지의 합을 구하는 문제
    - 알고리즘 1
      - 1+2+3+...+100=5050
      - 100번의 연산이 필요(덧셈 100번)
    - 알고리즘 2
      - 100*(1+100)/2=5050
      - 3번의 연산만으로 해결 가능
- 알고리즘의 시간 복잡도
  - 알고리즘의 작업량을 시간 복잡도(Time Complexity)로 표현함
  - 시간 복잡도 : 실행되는 명령문의 개수를 계산하여 실제 걸리는 시간을 측정
- 시간복잡도 표시
  - 빅-오 표기법(Big-O Notation)을 자주 사용
  - 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시
  - 계수는 생략하여 표시
  - O(3n+2) = O(3n) = O(n)
  - O(2n^2 + 10n + 100) = O(n^2)

### 배열
- 배열
  - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조
  - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음
- 1 차원 배열
  - 1 차원 배열 선언 예시
```python
arr = list()
arr = [ ]
arr = [0] * 10
arr = [1, 2, 3]
```
- 입력 받은 정수를 1 차원 배열에 저장하는 방법
  - 첫 줄에 양수의 개수 N이 주어집니다.
  - 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어집니다.

- 입력 예시
```
6
2 7 5 3 1 4
```
- 정수 N을 입력 받고, 공백으로 구분된 정수들을 리스트로 입력 받는 코드
```python
N = int(input())
arr = list(map(int, input().split()))
```
- 배열 원소의 합 계산 코드
```python
s = 0
for i in range(N):
    s += arr[1]
for x in arr:
    s += x
```
- 배열 원소 중 최댓값 max_v 찾기
```python
max_v = arr[0]    # 첫 원소를 최대로 가정
for i in range(1, N):
    if max_v < arr[i]
        max_v = arr[i]    # arr[i]가 더 크면 max_v를 arr[i]로 갱신
```
- 배열 원소 중 최댓값의 인덱스 max_idx 찾기
```python
max_idx = 0   # 첫 원소를 최대로 가정
for i in range(1, N):
    if arr[max_idx] < arr[i]:   # 더 큰값을 만나면
        max_idx = i    # max_idx 갱신
```
- 최댓값이 여러 개인 경우 마지막 인덱스 max_idx 찾기
```python
max_idx = 0
for i in range(1, N):
    if arr[max_idx] <= arr[i]:    # 더 큰값 또는 같은 값이면
        max_idx = i     # max_idx 갱신
```
- 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1 을 idx에 넣기
- 입력 예시
```
6 5 
2 7 5 3 1 7
```
- 정수 N, V를 입력받고, 공백으로 구분된 정수들을 리스트로 입력받는 코드
```python
N, V = map(int, input().split())    # N, 찾는 값 V
arr = list(map(int, input().split()))
```
- 배열 원소의 최댓값의 마지막 인덱스를 찾는 코드
```python
idx = -1    # 찾는 값이 없다고 가정
for i in range(N):
    if arr[i] == V:  # arr[i]가 찾는 값이면
        idx = i   # 인덱스 저장
        break    # for i 
```
### 버블 정렬
- 버블 정렬
  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 버블 정렬 과정
  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 맨 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
  - 시간복잡도 : O(n^2)

- 버블 정렬 알고리즘
```python
def BubbleSort(a, N):   # 정렬할 List a, 원소 수 N
    for i in range(N-1, 0, -1):     # 범위의 끝 위치
        for j in range(i):    # 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```