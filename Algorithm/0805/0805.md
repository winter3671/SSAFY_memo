### 카운팅 정렬
- 카운팅 정렬
  - 항목들의 순서를 결정하기 위해, 집합에 각 항목에 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 방식
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 집합 내의 가장 큰 정수를 알아야 충분한 공간을 할당 가능
  - 시간복잡도 : O(n+k)
- 카운팅 정렬 과정 예시
  - [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
  - DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스되는 카운트 배열 COUNTS에 저장
    - INDEX = 0, 1, 2, 3, 4
    - COUNTS = 1, 3, 1, 1, 2
  - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
  - COUNTS[i] = COUNTS[i-1]+COUNTS[i]
    - COUNTS = 1, 4, 5, 6, 8
  - DATA의 마지막 원소 1의 발생 횟수 COUNTS[1]을 감소시키고 TEMP에 1을 삽입한다.
    - COUNTS = 1, 3, 5, 6, 8
    - TEMP = 0, 0, 0, 1, 0, 0, 0, 0
  - COUNTS[4]를 감소시키고 TEMP에 4를 삽입한다.
    - COUNTS = 1, 3, 5, 6, 7
    - TEMP = 0, 0, 0, 1, 0, 0, 0, 4
  - COUNTS[2]를 감소시키고 TEMP에 2를 삽입한다.
    - COUNTS = 1, 3, 4, 6, 7
    - TEMP = 0, 0, 0, 1, 2, 0, 0, 4
  - 끝까지 반복하면 다음과 같다.
    - COUNTS = 0, 1, 4, 5, 6
    - TEMP = 0, 1, 1, 1, 2, 3, 4, 4
- 카운팅 정렬 코드 구현
```python
def counting_sort(DATA, TEMP, k):
    # DATA [] -- 입력 배열(원소는 0 이상 k 이하 정수)
    # TEMP [] -- 정렬된 배열
    # COUNTS [] -- 카운트 배열
    
    COUNTS = [0] * (k+1)

    for i in range(len(DATA)): # DATA[i] 발생횟수 기록
        COUNTS[DATA[i]] += 1
    for i in range(i, k+1): # COUNTS 값 조정 (누적)
        COUNTS[i] += COUNTS[i-1]
    for i in range(len(DATA)-1, -1, -1): # 3단계
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]
```

### 완전검색
- Baby-gin Game

  0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.

  그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.

  6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

- 완전 검색
  - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
  - 경우의 수가 상대적으로 작을 때 유용함
- 순열을 생성하는 방법
  - {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

### 탐욕 알고리즘
- 탐욕 알고리즘(Greedy)
  - 여러 경우 중 하나를 결정해야 할 때마다 최적이라고 생각하는 것을 선택해 나가는 방식으로 최종 해답에 도달하는 방식
  - 최적의 선택을 계속 수집하여 해답을 만들었더라도 최종적으로 최적이라는 보장은 없음
  - 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하는 것이 탐욕 알고리즘임
- 탐욕 알고리즘 과정
  - 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가한다
  - 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지 검사한다.
  - 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완서오디지 않았다면 1번 해 선택부터 다시 시작한다.
- 탐욕 알고리즘 예시
  - 거스름돈 줄이기 문제
    - 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄이는 방법을 탐색하는 문제
  - 해 선택
    - 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어듬
    - 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
  - 실행 가능성 검사
    - 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인
    - 초과한다면 마지막에 추가한 동전을 빼고, 해 선택으로 돌아가서 한 단계 작은 단위의 동전을 추가
  - 해 선택
    - 거스름돈을 확인해서 액수에 모자라면 다시 해 선택으로 돌아가서 거스름돈에 추가할 동전을 선택
- 탐욕 알고리즘을 활용한 Baby-gin 접근
  - 6개의 숫자는 6자리의 정수값으로 입력됨
  - counts 배열의 각 원소를 체크하여 run, triplet, baby-gin 여부를 판단
  - 입력 예시 : 444345
    - run 조사 후 run 데이터 삭제
    - 444로 남은 데이터가 triplet임. baby-gin 성립
  - 입력 예시 : 444456
    - triplet 조사 후 triplet 데이터 삭제
    - 456으로 남은 데이터가 run임. baby-gin 성립
  - 입력 예시 : 333456
    - run 조사 후 run 데이터 삭제
    - 336이 남아서 판별이 어려울 가능성 존재
    - triplet 조사 후 triplet 데이터 삭제
    - 456으로 남은 데이터가 run임. baby-gin 성립
- Baby-gin 접근 코드구현
```python
num = 456789 # BabyGin 확인할 6자리 수
c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
    c[num % 10] += 1  # c에 각 자리수 입력
    num //= 10

i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3: # triplet 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1: # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if run + tri == 2: print("Baby Gin")
else: print("Lose")
```
  - c리스트의 0을 12개를 만드는 이유는 자릿수를 늘려서 연산을 줄이기 위함
    - triplet은 7까지밖에 탐색이 불가능해서 이를 해결하려면 if문을 하나 더 만들어야함
    - 리스트를 늘려서 if문을 하나 줄인것
- Baby-gin 문제에서 자주 실수하는 오답
  - 입력받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run과 triplet을 확인하는 방법
  - [1, 2, 3, 1, 2, 3]은 baby-gin이지만, 정렬하면 [1, 1, 2, 2, 3, 3]으로 확인을 실패할 수 있음
  