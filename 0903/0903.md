### 진법 변환
- 10진수를 2진수로 변환
```python
def decimal_to_binary(n):
    binary_number = ""

    if n == 0:
        return "0"

    # 0보다 클 때까지 2로 나누면서 나머지를 정답에 추가
    while n > 0:
        remain = n % 2
        binary_number = str(remain) + binary_number 
        n //= 2

    return binary_number
```
- 10진수를 16진수로 변환
```python
def decimal_to_hexadecimal(n):
    hex_degits = "0123456789ABCDEF"     # 여러개를 변화시키지 않고 조회만 할 때: 문자열이 빠름
                                        # 여러개를 변화시켜야 할 때: 리스트 or 딕셔너리 고려
    hexadecimal_number = ""

    if n == 0:
        return 0

    # 0보다 클 때까지 16으로 나누면서 나머지를 정답에 추가
    while n > 0:
        remain = n % 16      # 0~15의 숫자를 인덱스로 생각 - hex_degits
        hexadecimal_number = hex_digits[remain] + hexadecimal_number
        n //= 16

    return hexadecimal_number
```
- 파이썬 내장함수에 진수 변환 함수가 있지만, 직접 구현하는 함수를 연습해야함
  - hex(): 16진수
  - dec(): 10진수
  - oct(): 8진수
  - bin(): 2진수
- 2진수를 10진수로 변환
```python
def binary_to_decimal(binary_str):
    decimal_number = 0
    pow = 0

    for digit in reversed(binary_str):
        if digit == "1":
            decimal_number += 2 ** pow
        pow += 1
        
    return decimal_number
```

### 비트 연산
- 비트 연산
  - 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함
- 비트 연산자
  - &: 비트 단위로 AND 연산을 함
    - a AND b: a, b 둘 다 1 일 때만 결과가 1, 그 외에는 0
  - |: 비트 단위로 or 연산을 함
    - a OR b: a, b 둘 중 하나라도 1이면 결과가 1, 그 외에는 0
  - ^: 비트 단위로 XOR 연산을 함
    - a XOR b: a, b중 하나만 1일 때 결과가 1, 그 외에는 0
  - '<<' : 특정 수 만큼 비트를 왼쪽으로 밀어냄
  - '>>' : 특정 수 만큼 비트를 오른쪽으로 밀어냄(우측 비트들이 제거됨)
  - ~: 모든 비트를 반전시킴(bitwise NOT)
    - 8-bit일 때 ~(0001 1111)은 1110 0000
- 진수 표현
  - 2진수는 0b를 접두사로 붙여 표현
    - ex) 0b1010 = 10
  - 16진수는 0x를 접두사로 붙여 표현
    - ex) 0xa = 10
- XOR의 특징
  - 어떤 값이든 특정 수로 2회 XOR을 하면 원래 수로 돌아옴
   - 7070 ^ 1004 = 6258
   - 6258 ^ 1004 = 7070
  - 비밀코드를 사전에 설정하면 암호화에 사용 가능
- 부분집합의 수
  - arr = [1, 2, 3, 4]의 부분집합의 수: 1 << len(arr)
- 전체 부분집합
```python
for i in range(1 << len(arr)):      # 부분집합 번호
    for idx in range(len(arr)):     # 각 원소들을 모두 확인
            # i: 부분집합 번호(각 자리의 포함 여부)
            # (1 << idx): 0b1, 0b10, 0b100, 0b1000
        if i & (1 << idx):
            print(arr[idx], end=" ")
    print()
```
- 합이 10인 부분집합들만 구하는 방법
```python
arr = [1, 2, 3, 4, 5, 6]
for i in range(1 << len(arr)):
    subset = []
    total = 0

    for idx in range(len(arr)):
        if i & (i << idx):
            subset.append(arr[idx])
            total += arr[idx]

    if total == 10:
        print(subset)
```
- 음수 표현 방법
  - 컴퓨터는 음수를 '2의 보수'로 관리함
    - 맨 앞자리 bit(MSB)는 음수 or 양수를 구분하는 비트임
    - 2의 보수 표기법: 수를 모두 뒤집고 +1을 더함
    - 10001의 2의 보수: 01110 + 1 = 01111
    - 1111000의 2의 보수: 0000111 + 1 = 0001000
  - -5를 2의 보수로 표현하는 방법(가정: 수를 8-bit로 저장하는 경우)
    - 수 5를 2진수로 나타내면 0000 0101
    - -5는 음수이므로 MSB는 1
    - 나머지 7-bit에 대해 수를 뒤집고 1을 더함
    - 1111 1011의 결과물 도출
- 2의 보수 특징
  - 2의 보수를 취한 수를 한번 더 2의 보수를 취하면 원래의 값으로 돌아옴
- bitwise NOT 연산자를 파이썬에서 수행하기
  - 파이썬에서는 ~4를 수행하면 -5가 출력됨
    - 4는 0b0100 (MSB: 양수이므로 0)
    - NOT 연산자로 인해 뒤집으면 1011이 됨
    - MSB는 1이 되었고, 나머지 bit는 011
    - 나머지 bit에 대해 2의 보수를 취하면 100 + 1이므로 5가 됨
    - 따라서 결과는 -5

### 실수
- 파이썬에서 실수 출력 방법
  - 파이썬은 f-string 문법을 지향
  - a.2f: a값을 소수점 셋째자리에서 반올림하여 표현
- 10진수 0.1을 2진수로 바꾸는 과정
  - 0.1 * 2 = 0.2  -> 0
  - 0.2 * 2 = 0.4  -> 0
  - 0.4 * 2 = 0.8  -> 0
  - 0.8 * 2 = 1.6  -> 1(정수부분)
    - 정수부분을 제외한 소수부분만 다시 *2를 계산
  - 0.6 * 2 = 1.2  -> 1
  - 0.2 * 2 = 0.4  -> 2 ...
  - 10진수 0.1 = 2진수 0.0001100110011...
    - 무한루프일 때 중간에 잘라서 근사치 처리
- 비트처리에서 생기는 오차
  - 0.1 + 0.1 + 0.1 == 0.3 : False?
  - 컴퓨터는 실수를 내부적으로 근사적으로 관리
  - 이진수 처리를 할 때 무한루프가 있는데, 이 과정에서 근사치를 저장함. 여기서 작은 오차가 발생
  
### 진수변환
- 10진수를 2진수로 변환
```python
a = 10
b = f'{a:b}'
# b: 1010

a = 10
b = f'{a:010b}'
# b: 0000001010, 총 10자리를 채움
```
- 10진수를 16진수로 변환
```python
a = 31
b = f'{a:x}'
# b: 1f
```
