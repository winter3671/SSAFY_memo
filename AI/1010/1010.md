### Numpy와 Pandas
- Numpy
  - 오직 숫자만 담는 특수 리스트. ndarray
  - 모든 데이터가 숫자라는 것을 확신하기 때문에 훨씬 빠르고 효율적인 방식으로 한 번에 수십만개의 데이터를 계산할 수 있음. 벡터화
- Pandas
  - 사용자 데이터, 상품 정보 등의 데이터의 관계와 구조는 매우 복잡
  - 복잡한 데이터들을 Python에서 즉시 엑셀 표 처럼 깔끔하게 정리할 수 있도록 해 주는 도구

### Numpy 활용하기
- ndarray
  - 1차원 배열: vector
    - AI에서 vector은 `숫자들이 일렬로 정리되어 있는 상태`를 의미
    - 예를 들어, 어떤 사람이 나이(25), 키(175), 몸무게(70)을 데이터로 가지고 있다면, 이 데이터들을 [25, 175, 70] 형태로 다룰 것이며, 이를 벡터라고 함
  - 2차원 배열: matrix
    - 벡터는 한 명의 정보를 가짐
    - 여러명의 데이터를 가지면 2차원 배열로 다루게 됨
```python
# 로컬 환경에서 진행하려면
# pip install numpy
# 코렙 환경이기 때문에 기본적으로 넘파이가 설치되어 있음

import numpy as np

# 1차원 배열 만들기
vector = np.array([1, 2, 3])
print(vector)

# 배열의 차원과 형태 확인
print("차원 (ndim):", vector.ndim)
print("형태 (shape):", vector.shape)
print("전체 요소 수 (size):", vector.size)

# [1 2 3]
# 차원 (ndim): 1
# 형태 (shape): (3,)
# 전체 요소 수 (size): 3
```
```python
# 2차원 배열 만들기
matrix = np.array([[1, 2, 3], [4, 5, 6]])
print(matrix)

# 배열의 차원과 형태 확인
print("차원 (ndim):", matrix.ndim)
print("형태 (shape):", matrix.shape)
print("전체 요소 수 (size):", matrix.size)

# [[1 2 3]
#  [4 5 6]]
# 차원 (ndim): 2
# 형태 (shape): (2, 3)
# 전체 요소 수 (size): 6
```
- Numpy 연산 방식 이해하기
  - 벡터화
    - 파이썬의 리스트의 경우, 수의 연산이더라도 각 연산 대상이 숫자가 맞는가 확인하는 과정을 거침.
      - `스칼라 * 스칼라` 연산 진행
    - 반면 Numpy의 경우, 모든 값이 숫자임이 보장되므로 위 과정 없이 `벡터 * 스칼라` 연산으로 수행 가능
  - 행렬의 기본 연산
    - 기본 규칙
      - 두 피연산자인 행렬의 크기는 완전히 동일하여야 한다.
        - 즉, (3, 2) 크기의 행렬과 (2, 3) 크기의 행렬은 덧셈이 불가능
  - 브로드캐스팅
    - 행렬의 사칙연산은 반드시 크기가 동일해야지만 수행 가능
    - Numpy에서 제공하는 특별한 기능이 BroadCasting
      - 연산 대상인 두 배열의 크기가 달라도, 작은 배열이 큰 배열에 맞춰 늘어남
      - 행과 열 둘 중 하나 이상은 동일해야 함
      - 행렬 곱 연산은 브로듵캐스팅 지원 x
```python
# 행렬과 벡터 브로드캐스팅
D = np.array([[1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]])
E = np.array([10, 20, 30])
print("행렬 + 벡터 =\n", D + E)

# 행렬 + 벡터 =
#  [[11 22 33]
#  [14 25 36]
#  [17 28 39]]
```
  - 행렬 곱
    - 두 개의 행렬을 곱하는 연산
    - (a, b)와 (b, c) 행렬 같이 맞닿아있는 수가 일치할 때만 행렬 곱 가능
      - (a, c)의 행렬이 결과물로 나옴
```python
# (2, 2) 크기의 행렬과 (2, 3) 크기의 행렬의 행렬 곱
A = np.array([[1, 2],
              [3, 4]])
B = np.array([[1000, 2000, 3000],
              [3000, 2000, 1000]])

# 행렬 곱 수행
C = np.dot(A, B)
print(C)

# 행렬 곱 연산자
# C = A @ B
# print(C)

# [[ 7000  6000  5000]
#  [15000 14000 13000]]
```

  - 행렬 전치
    - 행과 열을 서로 바꿔주는 연산
    - 현재 가지고 있는 matrix 정보의 행과 열을 뒤집을 때, 쉽게 전치하도록 하는 방법
```python
# 원본 데이터 행렬
data = np.array([[1, 2, 3],
                 [4, 5, 6]])

# 전치 행렬
transposed_data = data.T
print(transposed_data)

# [[1 4]
#  [2 5]
#  [3 6]]
```
- 데이터 정규화
  - AI 모델은 숫자의 크기에 매우 민감하게 반응
    - 키(175)와 몸무게(70)과 같이, 서로 다른 범위를 가진 데이터가 섞여있으면 특정 데이터에 민감하게 반응할 수 있음
    - 이 문제를 해결하기 위해, 모든 데이터를 비슷한 범위로 맞춰주는 과정이 필요
  - 가장 기본적인 방법은 각 데이터에서 평균을 빼고 표준편차로 나누는 방식
```python
data = np.array([100, 200, 300, 400, 500])

# 데이터의 평균과 표준편차 구하기
mean = np.mean(data)
std = np.std(data)
print(f"평균: {mean}, 표준편차: {std}")

# 평균: 300.0, 표준편차: 141.4213562373095

# 정규화 (벡터와 스칼라 연산 규칙과 동일)
  # data는 여전히 벡터임을 기억
normalized_data = (data - mean) / std
print("정규화된 데이터:", normalized_data)
print(f"정규화된 데이터의 평균: {np.mean(normalized_data)}, 표준편차: {np.std(normalized_data)}")

# 정규화된 데이터: [-1.41421356 -0.70710678  0.          0.70710678  1.41421356]
# 정규화된 데이터의 평균: 0.0, 표준편차: 0.9999999999999999
```

- 다양한 배열 초기화 방법과 무작위성 부여
  - AI가 학습을 하기 위해서 필요한 여러 요소들은 보통 무작위로 값이 정해짐
    - 이때의 값들 역시 벡터나 행렬과 같이 구성되어야 함
  - Numpy를 활용하여 다양한 형태의 배열을 생성할 수 있음
  - 다양한 배열 생성
```python
# 3x4 크기의 배열을 0으로 초기화
zeros_array = np.zeros((3, 4))
print("0으로 초기화된 배열:\n", zeros_array)

# 0으로 초기화된 배열:
#  [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]
```
```python
# 2x3 크기의 배열을 1로 초기화
ones_array = np.ones((2, 3))
print("1로 초기화된 배열:\n", ones_array)

# 1로 초기화된 배열:
#  [[1. 1. 1.]
#  [1. 1. 1.]]
```
```python
# 2x3 크기의 배열을 특정 값(예: 7)으로 초기화
full_array = np.full((2, 3), 7)
print("7로 초기화된 배열:\n", full_array)

# 7로 초기화된 배열:
#  [[7 7 7]
#  [7 7 7]]
```
```python
# 3x3 크기의 단위 행렬 생성
identity_matrix = np.eye(3)
print("단위 행렬:\n", identity_matrix)

# 단위 행렬:
#  [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]
```
```python
# 0부터 9까지의 정수를 갖는 1차원 배열 생성
arange_array = np.arange(10)
print("0부터 9까지의 정수 배열:\n", arange_array)

# 0부터 9까지의 정수 배열:
#  [0 1 2 3 4 5 6 7 8 9]
```
```python
# 0부터 1까지 균등 간격으로 나눈 5개의 값 생성
linspace_array = np.linspace(0, 1, 5)
print("0부터 1까지 균등 간격으로 나눈 5개의 값:\n", linspace_array)

# 0부터 1까지 균등 간격으로 나눈 5개의 값:
#  [0.   0.25 0.5  0.75 1.  ]
```
  - 무작위성 부여
    - 단, 매번 완전히 무작위 값이 나오게 될 경우에 잘못 계산될 수가 있으므로 seed를 고정
```python
# seed 설정 (재현 가능성을 위해)
np.random.seed(42)
# 의미가 있지는 않지만 대부분 random을 사용할 때 seed를 42로 사용

# 3x3 크기의 배열을 무작위 값으로 초기화
random_array = np.random.rand(3, 3)
print("무작위 값으로 초기화된 배열:\n", random_array)

# 무작위 값으로 초기화된 배열:
#  [[0.37454012 0.95071431 0.73199394]
#  [0.59865848 0.15601864 0.15599452]
#  [0.05808361 0.86617615 0.60111501]]

# 평균이 0이고 표준편차가 1인 정규분포를 따르는 3x3 크기의 배열 생성
normal_array = np.random.randn(3, 3)
print("정규분포를 따르는 무작위 값으로 초기화된 배열:\n", normal_array)

# 정규분포를 따르는 무작위 값으로 초기화된 배열:
#  [[ 0.49671415 -0.1382643   0.64768854]
#  [ 1.52302986 -0.23415337 -0.23413696]
#  [ 1.57921282  0.76743473 -0.46947439]]
```

### Pandas 활용하기
- 행과 열
  - 행 (Row) : 데이터 분석에서는 주로 `관측치(Obervation)`이라고 부름. 객체 하나의 모든 정보를 담고 있음
  - 열 (Column) : 특성(Feature)라고 부름. 모든 객체의 세부 정보를 담고 있음
- DataFrame
  - Pandas의 핵심. Numpy를 활용한 빠른 연산과 더불어, `namespace`도 함께 있어 직관적으로 데이터를 다룰 수 있음.
  - 데이터 초기화
    - 파이썬의 딕셔너리나 리스트의 데이터를 DataFrame으로 변환 가능
```python
import pandas as pd

# 리스트 데이터 초기화
data_list = [
    ['Alice', 25, 'New York'],
    ['Bob', 30, 'Los Angeles'],
    ['Charlie', 35, 'Chicago']
]

df_list = pd.DataFrame(data_list, columns=['이름', '나이', '도시'])
print(df_list)

#         이름  나이           도시
# 0    Alice  25     New York
# 1      Bob  30  Los Angeles
# 2  Charlie  35      Chicago
```
```python
# 딕셔너리 데이터 초기화
data = {
    '이름': ['Alice', 'Bob', 'Charlie', 'David', 'Eva', None, 'Grace', 'Hannah', 'Ian', 'Jack'],
    '나이': [25, 30, 35, None, 28, 22, None, 29, 31, 27],
    '도시': ['New York', None, 'Chicago', 'Houston', 'Phoenix', 'Philadelphia', 'San Antonio', None, 'San Diego', 'Dallas']
}

df = pd.DataFrame(data)
print(df)

#         이름    나이            도시
# 0    Alice  25.0      New York
# 1      Bob  30.0          None
# 2  Charlie  35.0       Chicago
# 3    David   NaN       Houston
# 4      Eva  28.0       Phoenix
# 5     None  22.0  Philadelphia
# 6    Grace   NaN   San Antonio
# 7   Hannah  29.0          None
# 8      Ian  31.0     San Diego
# 9     Jack  27.0        Dallas
```
- 데이터 탐색과 선택
  - 데이터 기본 정보 조회
    - .head() / .tail(): 상위 5개 / 하위 5개의 행만 조회
    - .info(): 각 컬럼이 어떤 종료의 데이터(숫자, 문자)를 담고 있는지, 비어있는 값(결측치)은 없는지 요약 정보를 알려줌
    - .describe(): 숫자형 컬럼들의 통계 정보를 요약해서 보여줌.
      - 평균, 최댓값, 최솟값 등
```python
print('\n 상위 5개 행 조회')
print(df.head())

#  상위 5개 행 조회
#         이름    나이        도시
# 0    Alice  25.0  New York
# 1      Bob  30.0      None
# 2  Charlie  35.0   Chicago
# 3    David   NaN   Houston
# 4      Eva  28.0   Phoenix
```
```python
print('\n 하위 5개 행 조회')
print(df.tail())

#  하위 5개 행 조회
#        이름    나이            도시
# 5    None  22.0  Philadelphia
# 6   Grace   NaN   San Antonio
# 7  Hannah  29.0          None
# 8     Ian  31.0     San Diego
# 9    Jack  27.0        Dallas
```
```python
print('\n 데이터 정보 조회')
print(df.info())

#  데이터 정보 조회
# <class 'pandas.core.frame.DataFrame'>
# RangeIndex: 10 entries, 0 to 9
# Data columns (total 3 columns):
#  #   Column  Non-Null Count  Dtype  
# ---  ------  --------------  -----  
#  0   이름      9 non-null      object 
#  1   나이      8 non-null      float64
#  2   도시      8 non-null      object 
# dtypes: float64(1), object(2)
# memory usage: 372.0+ bytes
# None
```
```python
print('\n 통계 정보 조회')
print(df.describe())

#  통계 정보 조회
#               나이
# count   8.000000
# mean   28.375000
# std     3.925648
# min    22.000000
# 25%    26.500000
# 50%    28.500000
# 75%    30.250000
# max    35.000000
```
  - 데이터 상세 조회와 필터링
    - 컬럼 선택
      - 특정 컬럼을 선택하여, 해당 컬럼에 대한 데이터만 반환
      - 이때 반환되는 데이터 타입은 `Series`라는 1차원 데이터가 됨
```python
print('\n 특정 열(나이) 조회')
age_series = df['나이']
print(age_series)
print(type(age_series))

#  특정 열(나이) 조회
# 0    25.0
# 1    30.0
# 2    35.0
# 3     NaN
# 4    28.0
# 5    22.0
# 6     NaN
# 7    29.0
# 8    31.0
# 9    27.0
# Name: 나이, dtype: float64
# <class 'pandas.core.series.Series'>
```
```python
print('\n 여러 열(이름, 도시) 조회')
name_city_df = df[['이름', '도시']]
print(name_city_df)
print(type(name_city_df))

#  여러 열(이름, 도시) 조회
#         이름            도시
# 0    Alice      New York
# 1      Bob          None
# 2  Charlie       Chicago
# 3    David       Houston
# 4      Eva       Phoenix
# 5     None  Philadelphia
# 6    Grace   San Antonio
# 7   Hannah          None
# 8      Ian     San Diego
# 9     Jack        Dallas
# <class 'pandas.core.frame.DataFrame'>
```
  - 행 선택
    - .loc: `이름(Label)`을 중심으로 행을 선택
    - .iloc: `순서(index)`를 기준으로 행을 선택
```python
print('\n 특정 행(이름이 Bob인 행) 조회 using .loc')
bob_row = df.loc[df['이름'] == 'Bob']
print(bob_row)
print(type(bob_row))

#  특정 행(이름이 Bob인 행) 조회 using .loc
#     이름    나이    도시
# 1  Bob  30.0  None
# <class 'pandas.core.frame.DataFrame'>
```
```python
print('\n 특정 행(두 번째 행) 조회 using .iloc')
second_row = df.iloc[1]
print(second_row)
print(type(second_row))

#  특정 행(두 번째 행) 조회 using .iloc
# 이름     Bob
# 나이    30.0
# 도시    None
# Name: 1, dtype: object
# <class 'pandas.core.series.Series'>
```
  - 조건 필터링
    - 불리언 인덱싱(Boolean Indexing)
      - 조건 만들기: 원하는 조건을 만들면, 해당 조건에 대한 True or False로 채워진 리스트가 반환
      - 필터 적용: 이 True/False 리스트를 다시 DataFrame에 씌우면, True인 행만 반환
```python
print('\n 나이가 30 이상인 조건 필터링')
age_filter = df['나이'] >= 30
print(age_filter)

#  나이가 30 이상인 조건 필터링
# 0    False
# 1     True
# 2     True
# 3    False
# 4    False
# 5    False
# 6    False
# 7    False
# 8     True
# 9    False
# Name: 나이, dtype: bool
```
```python
print('\n 나이가 30 이상인 행 조회')
filtered_df = df[age_filter]
print(filtered_df)

# print('\n 나이가 30 이상인 행을 한 코드로')
# print(df[df['나이'] >= 30])

#  나이가 30 이상인 행 조회
#         이름    나이         도시
# 1      Bob  30.0       None
# 2  Charlie  35.0    Chicago
# 8      Ian  31.0  San Diego
```
```python
print('\n 나이가 30 이상이고 도시가 Chicago인 행 조회')
print(df[(df['나이'] >= 30) & (df['도시'] == 'Chicago')])

#  나이가 30 이상이고 도시가 Chicago인 행 조회
#         이름    나이       도시
# 2  Charlie  35.0  Chicago
```
- 데이터 가공 및 분석
  - 결측치 조회 및 가공
    - .isnull(): 값이 비어있는 경우 True를 반환
    - .fillna(): 값이 비어있는 경우, 지정한 값으로 빈칸을 채움
      - 일반적으로 평균값, 중앙값, O
    - .dropna(): 결측치가 있는 행을 삭제
```python
# 결측치 조회
print('\n 결측치 조회')
print(df.isnull())

#  결측치 조회
#       이름     나이     도시
# 0  False  False  False
# 1  False  False   True
# 2  False  False  False
# 3  False   True  False
# 4  False  False  False
# 5   True  False  False
# 6  False   True  False
# 7  False  False   True
# 8  False  False  False
# 9  False  False  False
```
```python
# 결측치가 있는 행 조회
print('\n 결측치가 있는 행 조회')
print(df[df.isnull().any(axis=1)])

#  결측치가 있는 행 조회
#        이름    나이            도시
# 1     Bob  30.0          None
# 3   David   NaN       Houston
# 5    None  22.0  Philadelphia
# 6   Grace   NaN   San Antonio
# 7  Hannah  29.0          None
```
```python
# 결측치 채우기
print('\n 나이의 결측치를 평균값으로 채우기')
mean_age = df['나이'].mean()
print(f'나이 평균값: {mean_age}')

df['나이'] = df['나이'].fillna(mean_age)
print(df)

#  나이의 결측치를 평균값으로 채우기
# 나이 평균값: 28.375
#         이름      나이            도시
# 0    Alice  25.000      New York
# 1      Bob  30.000          None
# 2  Charlie  35.000       Chicago
# 3    David  28.375       Houston
# 4      Eva  28.000       Phoenix
# 5     None  22.000  Philadelphia
# 6    Grace  28.375   San Antonio
# 7   Hannah  29.000          None
# 8      Ian  31.000     San Diego
# 9     Jack  27.000        Dallas
```
```python
# 결측치가 있는 행 삭제
print('\n 결측치가 있는 행 삭제')
df_dropped = df.dropna()
print(df_dropped)

#  결측치가 있는 행 삭제
#         이름      나이           도시
# 0    Alice  25.000     New York
# 2  Charlie  35.000      Chicago
# 3    David  28.375      Houston
# 4      Eva  28.000      Phoenix
# 6    Grace  28.375  San Antonio
# 8      Ian  31.000    San Diego
# 9     Jack  27.000       Dallas
```
  - 그룹화 및 통계
    - .groupby(): 데이터를 특정 컬럼과 같은 범주로 묶음
    - aggregation(집계): 묶인 그룹에 대해 .mean(), .sum(), .count() 등을 적용하여 통계 결과를 얻음
    - 정렬
```python
# 그룹화
grouped = df.groupby('도시')
print(grouped)  # 그룹화 객체 출력

# <pandas.core.groupby.generic.DataFrameGroupBy object at 0x7cca29017740>
```
```python
print('\n 도시별 나이 평균')
print(grouped['나이'].mean())

#  도시별 나이 평균
# 도시
# Chicago         35.000
# Dallas          27.000
# Houston         28.375
# New York        25.000
# Philadelphia    22.000
# Phoenix         28.000
# San Antonio     28.375
# San Diego       31.000
# Name: 나이, dtype: float64
```
```python
# 집계
print('\n 도시별 나이 최대값과 최소값')
print(grouped['나이'].agg(['max', 'min']))

#  도시별 나이 최대값과 최소값
#                  max     min
# 도시                          
# Chicago       35.000  35.000
# Dallas        27.000  27.000
# Houston       28.375  28.375
# New York      25.000  25.000
# Philadelphia  22.000  22.000
# Phoenix       28.000  28.000
# San Antonio   28.375  28.375
# San Diego     31.000  31.000
```
```python
# aggregate: 여러 집계 함수를 동시에 적용
# 도시별 나이 최대값과 이름 개수
# grouped.aggregate({'나이': 'max', '이름': 'count'})
```
```python
# 정렬
print('\n 나이 기준 내림차순 정렬')
sorted_df = df.sort_values(by='나이', ascending=False)
print(sorted_df)

#  나이 기준 내림차순 정렬
#         이름      나이            도시
# 2  Charlie  35.000       Chicago
# 8      Ian  31.000     San Diego
# 1      Bob  30.000          None
# 7   Hannah  29.000          None
# 6    Grace  28.375   San Antonio
# 3    David  28.375       Houston
# 4      Eva  28.000       Phoenix
# 9     Jack  27.000        Dallas
# 0    Alice  25.000      New York
# 5     None  22.000  Philadelphia
```