### list
- 리스트
  - 여러 개의 값을 순서대로 저장하는, `변경 가능한` 시퀀스 자료형
- 리스트 표현
  - 대괄호 []안에 값들을 쉼표(,)로 구분하여 만듬
  - 숫자, 문자열, 다른 리스트 등 모든 종류의 데이터를 담을 수 있음.
  - 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음.
  - my_list_1 = []
  - my_list_2 = [1, 'a', 3, 'b', 5]
  - my_list_3 = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
- 리스트의 시퀀스 특징
  - 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 기능 사용 가능

### 중첩 리스트
- 중첩 리스트
  - 다른 리스트를 값으로 가진 리스트(my_list)
  - my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]
    - my_list의 'world'를 표현하고 싶다면?
    - my_list[4][1]
    - my_list[4][-1] -> '!!!'
    - my_list[-1][1][0] -> w
      - 문자열 또한 시퀀스이므로 중첩리스트의 형태로 표현가능

### 리스트의 가변성
- 문자열 vs 리스트
  - 문자열은 불변성이라는 특징이 있지만,
  - 리스트는 `그 내용을 자유롭게 수정, 추가, 삭제할 수 있음`
- 예시
  - 인덱싱으로 값 수정하기
    - my_list = [1, 2, 3, 4, 5]
    - my_list[1] = 'two'
    - print(my_list) -> [1, 'two', 3, 4, 5]
  - 슬라이싱으로 여러 값 한번에 바꾸기
    - my_list = [1, 2, 3, 4, 5]
    - my_list[2:4] = ['three', 'four']
    - print(my_list) -> [1, 2, 'three', 'four', 5]

### 튜플(tuple)
- 튜플
  - 여러 개의 값을 순서대로 저장하는 `변경 불가능`한 시퀀스 자료형
- 튜플 표현
  - 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦
  - 모든 종류의 데이터를 담을 수 있음
  - 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 차이가 있음
  - my_tuple_1 = ()
  - my_tuple_2 = (1,)
    - 튜플을 (1)과 같이 설정하면, 튜플의 형태가 아닌 1로 취급됨!! 주의할것
  - my_tuple_3 = (1, 'a', 3, 'b', 5)
  - my_tuple_4 = 1, 'hello', 3.14, True
    - 괄호 없이 다음과 같이 설정해도 튜플로 처리됨!
    - print(my_tuple_4) -> (1, 'hello', 3.14, True)
- 튜플의 시퀀스 특징
  - 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 기능을 모두 사용할 수 있음

### 튜플의 불변성
- 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음
- 튜플은 개발자가 사용하는 용도가 아닌, 파이썬이 자체적으로 내부동작을 처리하는데 주로 사용됨
  - x, y = 10, 20
    - 위 문장은 (x, y) = (10, 20)과 같음
  - x, y = 1, 2
  - x, y = y, x
    - 실제 내부동작은 다음과 같음
    - temp = (y, x)
    - x, y = temp
    - print(x, y) -> 2 1
  - 파이썬 내부동작에서는 list를 사용하지 않음
    - 가변성 때문에 안전성 확보가 어려움
- 다중할당, 값 교환, 함수 다중 반환 값 등에 사용됨

### range
- range
  - `연속된 정수` 시퀀스를 생성하는, `변경 불가능`한 자료형
  - 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 유용함
  - 실제로 모든 숫자를 메모리에 저장하는 대신, 시작값, 끝값, 간격이라는 규칙만 기억
    - 메모리를 매우 효율적으로 사용하는 함수
- range 기본 구문
  - range(stop)
    - 매개변수가 하나면 `stop`으로 인식함
    - start는 0이, step는 1이 기본값으로 자동 설정
    - range(5) -> 0, 1, 2, 3, 4
    - my_range_1 = range(5)
    - print(my_range_1) -> range(0, 5)
      - 변환없이 print를 하면 range함수 자체가 나옴
    - print(list(my_range_1)) -> [0, 1, 2, 3, 4]
  - range(start, stop)
    - range(1, 10) -> 1, 2, 3, 4, 5, 6, 7, 8, 9
  - range(start, stop, step)
    - range(2, 10, 2) -> 2, 4, 6, 8
    - range(5, 0, -1) -> 5, 4, 3, 2, 1

### range의 규칙
- 값의 범위 규칙
  - stop 값은 생성되는 시퀀스에 절대 포함되지 않음
    - range(1, 5)는 1부터 5 이전까지의 숫자를 의미. -> 1, 2, 3, 4
  - stop 값 바로 앞에서 시퀀스가 끝난다고 기억하기
- 증가/감소 값 규칙
  - step이 양수일 때는 start가 stop보다 작아야함
    - print(list(range(5, 1))) -> []
    - 규칙에 어긋나더라도 error은 나지 않음!
  - step이 음수일 때는 stop이 start보다 작아야 함
    - print(list(range(1, 5, -1))) -> []
- range 활용 예시
  - 주로 반복문과 함께 활용 예정
  - for i in range(1, 10):

### dict(딕셔너리)
- 딕셔너리
  - `key - value 쌍`으로 이루어진 `순서와 중복이 없는` `변경 가능`한 자료형
    - 순서가 없음(인덱스가 없음)
    - 대신 key값으로 구분가능
- 딕셔너리 표현
  - 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음
  - 값 1개는 키와 값이 쌍으로 이루어져 있음
    - Key는 값을 식별하기 위한 고유한 이름표로, `중복이 불가능`
    - Value는 키에 해당하는 실제 데이터. `중복 가능`
  - 각 값에는 순서가 없음
  - my_dict_1 = {}
  - my_dict_2 = {'key': 'value'}
    - 위 딕셔너리의 값은 1개
  - my_dict_3 = {'apple': 12, 'list': [1, 2, 3]}
  - 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서가 유지됨
    - 하지만 그렇다고 해서 순서가 있는것은 아님!
    - 딕셔너리는 `순서가 없는 자료형`이라는 특징과 `Key를 통한 접근`이라는 특징을 가지고 있음
- 딕셔너리 규칙
  - Key의 규칙
    - 고유해야함
      - Key는 중복될 수 없음
    - 변경 불가능한 자료형만 사용 가능
      - str, int, float, tuple : 사용 가능
      - list, dict : 사용 불가능
  - Value의 규칙
    - 어떤 자료형이든 자유롭게 사용 가능
- 딕셔너리 값 접근 방법
  - Key에 접근 시 대괄호 사용
  - my_dict = {'name': '홍길동', 'age' 25}
  - print(my_dict['name']) -> '홍길동'
  - print(my_dict['test']) -> KeyError: 'test'
    - 존재하지 않는 Key로 접근하면 KeyError이 발생하며 프로그램이 멈춤
- 딕셔너리 값 추가 및 변경
  - my_dict = {'apple': 12, 'list': [1, 2, 3]}
  - my_dict['banana'] = 50
  - print(my_dict) -> {'apple': 12, 'list': [1, 2, 3], 'banana': 50}
    - 딕셔너리의 값 추가 가능
  - my_dict['apple'] = 100
  - print(my_dict) -> {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
    - 딕셔너리의 값 변경 가능
- 딕셔너리는 데이터에 순서가 필요 없고, 각 데이터에 의미있는 이름을 붙여 관리할 때 사용
  - 사람의 인적 정보, 게임캐릭터의 능력치 등

### set(세트)
- set
  - 순서와 중복이 없는 변경가능한 자료형
  - 주로 집합연산을 할 때 사용됨
    - 중복이 없는 특징 때문
- 세트 표현
  - 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦
  - my_set_1 = set()
  - my_set_2 = {1, 2, 3}
- 세트의 특징
  - 중복을 허용하지 않음
    - 똑같은 값은 단 하나만 존재할 수 있음
  - 순서가 없음
    - 인덱싱(set[0])이나 슬라이싱(set[0:2])을 사용할 수 없음
  - 비어있는 세트는 비어있는 딕셔너리와 혼동될 수 있으므로 set()로 만듦
- 세트의 집합 연산
  - my_set_1 = {1, 2, 3}
  - my_set_2 = {3, 6, 9}
  - print(my_set_1 | my_set_2) -> {1, 2, 3, 6, 9}
    - 합집합
  - print(my_set_1 - my_set_2) -> {1, 2}
    - 차집합
  - print(my_set_1 & my_set_2) -> {3}
    - 교집합
### Other Type
- None
  - 파이썬에서 `값이 없음`을 표현하는 특별한 데이터 타입
  - 숫자 0이나 빈 문자열('')과는 다름
  - `값이 존재하지 않음` 또는 `아직 정해지지 않음`이라는 상태를 나타내기 위해 사용
  - 내용물이 없는 '빈 상자'와 같음
  - 반드시 None와 같이 대문자 N을 사용할 것!
    - 소문자로 사용하면 문자로 처리됨
- None 표현
  - my_variable에 아직 아무 값도 할당하고 싶지 않을 때
  - my_variable = None
  - print(my_variable) -> None
- Boolean
  - 참(True)과 거짓(False), 단 두가지의 값만 가지는 데이터 타입
  - 프로그램의 흐름을 제어하는 조건문에서 '맞다' 또는 '틀리다'를 판단하는 역할을 함
  - True와 False 같이 반드시 맨 앞 문자는 대문자로 사용할 것!
  - print(10 > 5) -> True
  - print(10 == 5) -> False
  - 주로 조건 / 반복문과 함께 사용될 예정

### Collection
- 여러 개의 값을 하나로 묶어 관리하는 데이터 타입을 분류하는 말
- str, list, tuple, range, set, dict 데이터 타입이 모두 Collection에 분류됨

### 불변과 가변
- 불변 vs 가변
  - 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 '불변'과 '가변' 두 그룹으로 나뉨
  - 불변
    - 변경 불가, 안정성, 예측 가능의 특징
    - str, tuple, range
  - 가변
    - 변경 가능, 유연성, 효율성의 특징
    - list, dict, set

### 형변환
- 형변환
  - 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
  - 문자열 '100'을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 등
  - 암시적 형변환과 명시적 형변환이 있음
- 암시적 형변환
  - 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
  - 데이터 손실을 막기 위해 더 정밀한 타입으로 자동변환함
    - 정수와 실수가 있으면 더 범위가 큰 실수로 변환해줌
  - 개발자가 신경 쓰지 않아도 `더 안전한 쪽`으로 파이썬이 처리해 주는 것
  - print(3 + 5.0) -> 8.0
    - 정수와 실수의 덧셈에서 실수로 변환
  - print(True + 3) -> 4
    - 불리언과 정수의 덧셈
    - True는 1, False는 0으로 변환됨
  - print(True + False) -> 1
    - 불리언간의 덧셈
- 명시적 형변환
  - 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
  - 서로 다른 타입의 데이터를 호환되도록 맞추는 과정
  - 파이썬은 타입에 엄격해서, 모양이 다른 플러그는 바로 연결할 수 없음
  - print(int(3.5)) -> 3
  - print(float('3.5')) -> 3.5
  - print(int('3.5')) -> ValueError
    - str -> int는 형식에 맞는 숫자만 가능
  - print(str(1) + '등') -> 1등
    - int -> str은 모두 가능
  - 모두 외우기 어려우니, 직접 하나씩 해보면서 하자

### 연산자
- 산술 연산자
  - 수학적 계산을 위해 사용되는 연산자
  - +, -, *, /, //, % 등
- 복합 연산자
  - 연산과 할당이 함께 이뤄짐
  - +=
    - a += b 는 a = a + b 라는 의미
  - 다른 산술연산자에 대한 지원도 모두 가능(-=, *= 등)
- 비교 연산자
  - 두 값을 비교하여 그 관계가 맞는지 틀리는지를 판단
  - 반드시 True나 False로 반환
  - <, <=, >, >=, == 등
  - 같지 않음 표시는 !=로 표현
  - is, is not 또한 비교연산자임
    - == 연산자는 값이 같은지를 비교하지만 is 연산자는 객체 자체가 같은지를 비교
    - == 연산자는 동등성을, is 연산자는 식별성의 특징이 있음
      - print(2 == 2.0) -> True
      - print(2 is 2.0) -> False
    - 예를 들어, 1 == True의 경우는 파이썬이 내부적으로 True를 1로 간주하므로 True 결과가 나옴.
      - print(1 == True) -> True
      - print(1 is True) -> False
    - is 연산자는 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용됨
    - is는 '정체성'을, ==은 '가치'를 비교하기 때문에 is 대신 ==을 사용
    - print(2 is 2.0)에서 '두 객체가 메모리상에서 같은 존재인가?'를 물어서 False가 출력됨
      - 하지만 우리의 의도는 '두 객체의 값이 논리적으로 같은가?'이므로 ==을 사용해야함
    - `is 연산자는 주로 싱글턴 객체를 비교 할 때 사용함`
      - 싱글턴 객체 : 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 객체
      - None, True, False
      
      - x = None
      - if x is None:  (권장)
      - if x == None:  (비권장)
    - 리스트 또는 다른 가변 객체를 비교할 때, 값 자체가 같은 지 확인하려면 ==를 사용
      - a = [1, 2, 3]
      - b = [1, 2, 3]
      - print(a == b) -> True
      - print(a is b) -> False (서로 다른 리스트 객체이기 때문)

      - b = a
      - print(a is b) -> True (같은 객체를 가리키기 때문)
- 논리 연산자
  - 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용
  - and, or, not이 대표적임
  - 비교 연산자와 함께 사용 가능
    - num = 15
    - result = (num > 10) and (num % 2 == 0)
    - print(result) -> False

    - name = 'Alice'
    - age = 25
    - resule = (name == 'Alice') or (age == 30)
    - print(result) -> True

### 단축 평가
- 단축 평가
  - 꼭 필요한 계산만 하고, 결과가 이미 정해졌다면 굳이 뒤에 있는 코드를 확인하지 않음
  - 평가를 단축한다고 해서 단축 평가라고 함
- 파이썬의 참과 거짓
  - 거짓으로 취급되는 값들
    - False, 숫자 0, 빈 문자열 '', 빈 리스트 [], None 등
  - 참으로 취급되는 값들
    - True, 그리고 '거짓'이 아닌 모든 값
- 단축 평가 동작 정리
  - and 연산자
    - 하나라도 '거짓'이면 바로 '거짓'으로 결론
    - 처음 만나는 '거짓'값을 바로 반환
    - 만약 끝까지 갔는데 모든 값이 '참'이면, 맨 마지막 '참'값을 반환
  - or 연산자
    - 하나라도 '참'이면 바로 '참'으로 결론
    - 처음 만나는 '참'값을 바로 반환
    - 만약 끝까지 갔는데 모든 값이 '거짓'이면, 맨 마지막 '거짓'값을 반환
- 예시
  - item1 = '지도'
  - item2 = '나침반'
  - result = item1 and item2
  - print(result) = 나침반

  - item1 = ''
  - item2 = '나침반'
  - result = item1 and item2
  - print(result) = ''
    - and는 item1('')을 보자마자 ''을 최종 결과로 선택하고 평가를 멈춤
    - item2의 값에 상관없음
- 단축 평가를 하는 이유
  - 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 하기 위해서
  - 오류를 방지하고 간결한 코드 작성에 유용하게 사용됨

### 연산자
- 멤버십 연산자
  - 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자는
  - in
    - 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인
    - word = 'hello'
    - print('h' in word) -> True
  - not in
- 시퀀스형 연산자
  - 시퀀스 자료형에 특별한 의미로 사용되는 연산자
  - +는 결합 연산자로, 시퀀스를 연결하는 기능을 함
    - print('Gildong' + 'Hong') -> Gildong Hong
  - *는 반복 연산자로, 시퀀스를 반복하는 기능을 함
    - print('hi' * 5) -> hihihihihi

### 참고자료
- Trailing Comma(후행 쉼표)
  - 컬렉션의 마지막 요소 뒤에 붙는 쉼표
  - 하나의 요소로 구성된 튜플을 만들 때는 필수로 사용
    - x = (1,)
  - 일반적으로는 선택사항
  - config = {
    'host': 'localhost',
    'port': 8000,
    'debug': True,
    }
  - 딕셔너리에서 많이 사용함(가독성 측면에서 좋음)
  - 한 줄 작성 시에는 불필요
