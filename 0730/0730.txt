### 절차 지향과 객체 지향
- 절차 지향
  - 데이터와 함수가 분리되어 있음, 함수를 메인으로 작동
  - 함수와 로직을 중심으로 작성
  - 데이터를 순차적으로 정리함

name = "Alice"
age = 25

def intruduce(name, age):
    print(f"안녕하세요, {name}입니다. 나이는 {age}살입니다.")
    
introduce(name, age)

  - 함수를 어떤것부터 호출하는지 순서가 중요(호출의 흐름이 중요)
  - 복잡성 증가
    - 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움
  - 유지보수 문제
    - 코드 수정 시 영향 파악이 어려움
- 객체 지향
  - 데이터를 메인으로 하는 프로그래밍
  - 클래스와 인스턴스 존재
    - 클래스는 설계도, 인스턴스는 실제 물건의 역할

class Person:
    def __init__(self, name, age)
        self.name = name
        self.age = age
    
    def introduce(self):
        print(f"안녕하세요, {self.name}입니다. 나이는 {self.age}살입니다.")

alice = Person("Alice", 25)
alice.introduce()

  - introduce(self)는 class 안에 들어있으므로 함수가 아닌 메서드라고 표현
  - alice는 인스턴스임
  - 객체 지향 프로그래밍은 데이터와 함수를 하나의 단위(객체)로 묶어서 조직적으로 관리함
    - 데이터와 메서드의 결합이 이루어짐
- 절차지향 vs 객체지향
  - 절차지향
    - 데이터와 해당 데이터를 처리하는 함수(절차)가 분리
    - 함수 호출의 흐름이 중요
    - "어떤 순서로 처리할까?"가 중요
    - 함수(데이터)의 형태
  - 객체 지향
    - 데이터와 해당 데이터를 처리하는 메서드를 하나의 객체로 묶음
    - 객체 간 상호작용과 메시지 전달이 중요
    - "어떤 객체가 이 문제를 해결할까?"
    - "이 객체는 어떤 속성과 기능을 가질까?"가 중요
    - 데이터.메서드()의 형태

### 객체와 클래스
- 객체
  - 실제 존재하는 사물을 추상화한 것
  - '속성'과 '동작'을 가짐
- 클래스
  - 객체를 만들기 위한 설계도
  - 데이터와 기능을 함께 묶는 방법을 제공
  - 파이썬에서 타입을 표현하는 방법

### 클래스
- 클래스
  - 하나의 구조 안에 데이터(변수)와 기능(함수)를 함께 정의하는 도구
- 클래스 예시
  - 클래스 : 소나타 설계도
  - 인스턴스 : 소나타 1, 소나타 2, ...
  - 속성(변수) : 색깔, 가죽종류, 지역, 차량번호 등
  - 기능(메서드) : 직진하기, 후진하기, 우회전하기 등
- 클래스 정의
  - class 키워드
  - 클래스 이름은 파스칼 케이스(Pascal Case)방식으로 작성
    - 지금까지는 스네이크 케이스를 많이 사용했음(my_package)
    - 파스칼 케이스는 구분을 대문자로 사용함(MyClass)

class MyClass:
    pass

- 클래스 예시
  - __init__ 메서드는 '생성자 메서드'로 불리며, 새로운 객체를 만들 때 필요한 초기값을 설정함

class Person:
    def __init__(self, name, age):
        self.name = name -> 인스턴스 속성
        self.age = age -> 인스턴스 속성
    
    def introduce(self)
        print(f"안녕하세요. 저는 {self.name}, 나이는 {self.age}살입니다.")

# 인스턴스
- 인스턴스
  - 클래스를 통해 실제로 만들어진 객체
  - 같은 클래스로 여러 인스턴스를 만들 수 있으며, 각 인스턴스는 클래스 구조를 따라 동작하지만 서로 독립된 데이터를 가질 수 있음.
- 인스턴스 예시
  - 클래스가 설계도라면, 인스턴스는 그 설계도로부터 실제로 만든 '개별 물건'

p1 = Person("Alice", 25)
print(p1.name) -> Alice
p1.introduce() -> "안녕하세요. 저는 Alice, 나이는 25살입니다."
p2 = person("Bella", 30)
p2.introduce() -> "안녕하세요. 저는 Bella, 나이는 30살입니다."

  - Person("Alice", 25)라고 하면 Person이라는 설계도로부터 이름이 Alice이고, 나이가 25인 '사람 객체'가 탄생

### 클래스와 인스턴스
- 클래스와 인스턴스
  - 클래스를 정의한다는 것은 공통된 특성과 기능을 가진 틀을 만드는 것임
  - 실제 활동하는 개별 객체들은 이 틀에서 생성된 인스턴스
  - 공통된 특성과 기능을 가진 틀을 만드는 것은 곧 새로운 타입을 만드는 행위임

name = "Alice"
print(type(name)) -> <class 'str'>

  - 변수 name의 타입은 str 클래스이다.
  - 변수 name은 str 클래스의 인스턴스이다.
  - 하나의 객체(object)는 특정 클래스의 인스턴스(instance)이다.

### 클래스 구성요소
- 클래스 구조
  - 생성자 메서드
    - 인스턴스 생성 시 자동 호출되는 특별한 메서드
    - __init__이라는 이름의 메서드로 정의
    - 인스턴스 변수의 초기화 담당

class Circle:
    pi = 3.14

    def __init__(self, radius):
        self.radius = radius

c1 = Circle(1)
c2 = Circle(2)  -> 인스턴스 생성

  - 인스턴스 변수(속성)
    - 각 인스턴스 별 고유한 속성
    - self.변수명 형태로 정의
    - 인스턴스마다 독립적인 값 유지

print(c1.radius) -> 1
print(c2.radius) -> 2

  - 클래스 변수(속성)
    - 모든 인스턴스가 공유하는 속성
    - 클래스 내부에서 직접 정의

print(c1.pi) -> 3.14
print(c2.pi) -> 3.14

### 클래스 변수와 인스턴스 변수
- 클래스 변수와 인스턴스 변수
  - 클래스 변수와 동일한 이름으로 인스턴스 변수 생성 시, 클래스 변수가 아닌 인스턴스 변수에 먼저 참조하게 됨
  - class.class_variable으로 클래스 변수 참조 가능

class Circle:
    pi = 3.14

    def __init__(self, radius):
        self.radius = radius
    
c1 = Circle(5)
c2 = Circle(10)
print(c1.radius) -> 5
print(c2.radius) -> 10

c1.pi = 100
print(c1.pi) -> 100
print(Circle.pi) -> 3.14

  - 본인의 변수를 먼저 찾고, 없으면 클래스의 변수를 찾는 순서임
  - 같은 이름으로 인스턴스 변수 생성 시, 더이상 클래스 변수에는 참조가 불가능함

### 메서드
- 메서드
  - 클래스 내부에 정의된 함수로, 해당 객체가 어떻게 동작할지를 정의
- 메서드 종류
  - 인스턴스 메서드
  - 클래스 메서드
  - 스태틱 메서드

### 인스턴스 메서드
- 인스턴스 메서드
  - 인스턴스의 상태를 조작하거나 동작을 수행함
  - 인스턴스마다 독립적으로 행동할 수 있게 만드는 것이 인스턴스 메서드
- 인스턴스 메서드 구조
  - 클래스 내부에 정의되는 메서드의 기본형임
  - 반드시 첫번째 인자로 인스턴스 자신(self)을 받음
  - 인스턴스의 속성에 접근하거나 변경 가능

class MyClass:

    def instance_method(self, arg1, ...):
        pass

  - self는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능하지만, 다른 이름을 사용하지 않을 것을 강력히 권장함
- self 동작 원리
  - 클래스가 메서드를 호출하고, 그 첫 인자로 문자열 인스턴스가 들어가는 형태

'hello'.upper() ==
str.upper('hello')
-> str 클래스가 upper 메서드를 호출했고, 그 첫번째 인자로 문자열 인스턴스가 들어간 것
-> 인스턴스 메서드의 첫번째 인자가 반드시 자기 자신인 이유!!

  - 'hello'.upper()은 str.upper('hello')를 객체 지향 방식의 메서드로 호출하는 표현(단축형 호출)

- 인스턴스 메서드 활용

class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        self.count += 1

c = Counter()
c.increment()
print(c.count) -> 1

- 생성자 메서드
  - 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
  - 인스턴스 변수들의 초기값을 설정
- 생성자 메서드 활용

class Person:
    def __init__(self, name):
        self.name = name
        print("인스턴스가 생성되었습니다.")

    def greeting(self):
        print(f"안녕하세요 {self.name}입니다.")

person1 = Person("지민") -> 인스턴스가 생성되었습니다.
person1.greeting() -> 안녕하세요. 지민입니다.

  - self.name = name 에서 왼쪽 name은 인스턴스 변수 name이고, 오른쪽 name은 생성자 메서드의 매개변수 이름임

### 클래스 메서드
- 클래스 메서드
  - 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행
- 클래스 메서드 구조
  - @classmethod 데코레이터를 사용하여 정의
  - 호출 시, 첫번째 인자로 해당 메서드를 호출하는 클래스(cls)가 전달됨
  - 클래스를 인자로 받아 클래스 속성을 변경하거나 읽는 데 사용

class MyClass:

    @classmethod
    def class_method(cls, arg1, ...)
        pass

  - cls는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능하나, 다른 이름을 사용하지 않을 것을 강력히 권장
- 클래스 메서드 활용

class Person:
    population = 0

    def __init__(self, name):
        self.name = name
        Person.increase_population()

    @classmethod
    def increase_population(cls):
        cls.population += 1
  
person1 = Person("Alice")
person2 = Person("Bella")
print(Person.population)  -> 2

### 스태틱 메서드
- 스태틱(정적) 메서드
  - 클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드
- 스태틱 메서드 구조
  - @staticmethod 데코레이터를 사용하여 정의
  - 호출 시 자동으로 전달받는 인자가 없음`(self, cls를 받지 않음)`
  - 인스턴스나 클래스 속성에 직접 접근하지 않는, '도우미 함수'와 비슷한 역할

class MathUtils:

    @staticmethod
    def add(a, b):
        return a + b

print(MathUtils.add(3, 5)) -> 8

### 참고
- 매직 메서드
  - __str__(self)와 같이 __가 있는 메서드는 특수한 동작을 위해 만들어짐
  - 특정 상황에 자동으로 호출됨

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def __str__(self)
        return f"원의 반지름: {self.radius}"

c1 = Circle(10)
c2 = Circle(1)
print(c1) -> 원의 반지름: 10
print(c2) -> 원의 반지름: 1


