### Django Form
- HTML Form
  - 지금까지 사용자로부터 데이터를 제출받기 위해 활용한 방법
  - 비정상적 혹은 악의적인 요청을 필터링 할 수 없음
    - 유효한 데이터인지에 대한 확인이 필요
- 유효성 검사
  - 수집한 데이터가 정확하고 유효한지 확인하는 과정
  - 사용자가 입력한 데이터가 올바른 형식인지 자동으로 점검하는 기능을 제공
  - 유효성 검사를 구현하기 위해서는 입력 값, 형식, 중복, 범위, 보안 등 많은 것들을 고려해야 함
    - 이러한 과정과 기능은 개발하는 것이 아닌, Django가 제공하는 form을 사용
  
### Form Class
- Django Form
  - 사용자 입력 데이터를 수집하고, 처리 및 유효성 검사를 수행하기 위한 도구
  - 빠르고 일관된 입력 검증 기능을 구현 가능
- Form Class 정의
  - Form Class를 상속받아 내용과 제목에 대한 사용자 입력을 받는 ArticleForm을 정의
```python
# articles/forms.py
from django import forms

class ArticleForm(forms.Form):
  title = forms.CharField(max_length=10)
  content = forms.CharField()
```
  - models.py에서 content는 models.TextField()를 사용했지만, forms에서는 TextField 대신 CharField를 사용
    - forms.에는 TextField()가 없음

### Widgets
- Widgets
  - HTML 'input' element의 표현을 담당
```python
content = forms.CharField(widget=forms.Textarea)
```
  - CharField가 Textfield처럼 바뀜

### Django ModelForm
- Form vs ModelForm
  - 공통점: 사용자 입력 데이터를 받음
  - 차이점
    - Form: 사용자 입력 데이터를 DB에 저장하지 않을 때
      - ex. 검색, 로그인
    - ModelForm: 사용자 입력 데이터를 DB에 저장해야 할 때
      - ex. 게시글 작성, 회원가입
- ModelForm
  - Model과 연결된 Form을 자동으로 생성해주는 기능을 제공
    - Model과 연결된 Form: Form이 이미 Model 구조를 알고 있음, input의 정보를 알고 있음
- ModelForm class 정의
```python
# articles/forms.py

from django import forms
from .models import Article

class ArticleForm(forms.ModelForm):
  class Meta:
    model = Article
    fields = '__all__'
```
- Meta : 메타데이터
  - 데이터를 설명하는 데이터(사진)

### Meta class
- Meta class
  - ModelForm의 정보를 작성하는 곳
  - ModelForm 내부에서 어떤 모델과 연결할 지, 어떤 필드를 사용할 지 등을 정의하는 설정 공간
  - 폼의 동작 방식을 제어하는 핵심 역할
- 'fields' 및 'exclude' 속성
```python
class Meta:
  model = Article
  fields = ('title',)
```
  - title만 출력
- exclude 속성을 사용하여 모델에서 포함하지 않도록 필드를 지정할 수도 있음
```python
class Meta:
  model = Article
  exclude = ('title',)
```
  - title을 제외하고 출력
- Meta class 주의사항
  - Django에서 ModelForm에 대한 추가 정보나 속성을 작성하는 클래스 구조를 Meta 클래스로 작성 했을 뿐이며, 파이썬의 inner class와 같은 문법적인 관점으로 접근하지 말 것

### ModelForm 적용
```python
# articles/views.py
from .forms import ArticleForm

def create(request):
  form = ArticleForm(request.POST)
  if form.is_valid():
    article = form.save()
    return redirect('articles:detail', article.pk)
  context = {
    'form': form,
  }
  return render(request, 'articles/new.html', context)
```
- is_valid()
  - 여러 유효성 검사를 실행하고, 데이터가 유효한지 여부를 Boolean으로 반환
- 공백 데이터가 유효하지 않은 이유와 에러 메시지가 출력되는 과정
  - 별도로 명시하지 않았지만, 모델 필드에는 기본적으로 빈 값은 허용하지 않는 제약조건이 설정되어 있음
  - 빈 값은 is_valid()에 의해 False로 평가되고, form 객체에는 그에 맞는 에러 메세지가 포함되어 다음 코드로 진행됨

### save 메서드
- save()
  - 데이터베이스 객체를 만들고 저장하는 ModelForm의 인스턴스 메서드
  - 키워드 인자 instance 여부를 통해 생성할 지, 수정할 지를 결정

### View 함수 구조 변화
- new & create view 함수 간 공통점과 차이점
  - 공통점
    - 데이터 생성을 구현하기 위함
  - 차이점
    - new는 GET method 요청만을, create는 POST method 요청만을 처리
- view 함수 구조화의 목적
  - HTTP request method 차이점을 활용해 동일한 목적을 가지는 2개의 view 함수를 하나로 구조화

### new & create 함수 결합
```python
def create(request):
  if request.method == 'POST':
    form = ArticleForm(request.POST)
    if form.is_valid():
      article = form.save()
      return redirect('articles:detail', article.pk)
  else:
    form = ArticleForm()
  context = {
    'form': form,
  }
  return render(request, 'article/new.html', context)
```
- 기존 new 관련 코드 수정
  - 사용하지 않게 된 new url 제거
```python
# urls.py
# path('new/', views.new, name='new'),
```
  - new 관련 키워드를 create로 변경
```html
<!-- index.html -->
 <a href="{% url 'articles:create' %}">CREATE</a>
```
```python
# views.py
def create()
...
return render(request, 'articles/create.html', context)
```
- request method에 따른 요청의 변화
  - (GET) articles/create/ : 게시글 생성 페이지를 요청
  - (POST) articles/create/ : 게시글 생성 요청
  