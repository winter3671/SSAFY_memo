### 메서드
- 메서드
  - 객체에 속한 함수(class 내부에 정의되는 함수)
  - 데이터 구조의 데이터를 조작하거나 특정 기능을 수행하기 위해 사용
  - 메서드는 클래스에 속해 있는 함수이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재함
- 메서드 호출방법
  - 데이터 타입 객체.메서드()

print('hello'.capitalize()) -> Hello
numbers = [1, 2, 3]
numbers.append(4)
print(numbers) -> [1, 2, 3, 4]

  - 객체(데이터)에게 원하는 명령(메서드)를 내리는 방법

### 문자열 메서드
- .find(x)
  - x의 첫번째 위치를 반환. 없으면 -1을 반환

print('banana'.find('a')) -> 1
print('banana'.find('z')) -> -1

- .index(x)
  - x의 첫번째 위치를 반환. 없으면 오류 발생

print('banana'.index('x')) -> 1
print('banana'.index('z')) -> ValueError: substring not found

- .isupper()
  - 문자열이 모두 대문자로 이루어져 있는지 확인

string1 = 'HELLO'
string2 = 'Hello'
print(string1.isupper()) -> True
print(string2.isupper()) -> False

- .islower()
  - 문자열이 모두 소문자로 이루어져 있는지 확인

string2 = 'Hello'
string3 = 'hello'
print(string2.islower()) -> False
print(string3.islower()) -> True

- .isalpha()
  - 문자열이 알파벳으로만 이루어져 있는지 확인

string2 = 'Hello'
print(string2.isalpha()) -> True

### 문자열 조작 메서드(새로운 문자열 반환)
- .replace(old, new[,count])
  - 바꿀 대상 글자를 새로운 글자로 바꿔서 반환
  - 대괄호[,count]는 선택 인자
  - [,count]에서 앞에서부터 바꿀 개수를 지정가능
  - [,count]가 없으면 일치하는 전체를 바꿔서 반환

text = 'Hello, world! world world'
new_text1 = text.replace('world', 'Python')
new_text2 = text.replace('world', 'Python', 1)
print(new_text1) -> Hello, Python! Python Python
print(new_text2) -> Hello, Python! world world

- .strip([chars])
  - 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
  - [chars]에 문자를 넣으면 그 문자를 제거함

text = '   Hello, world!   '
new_text = text.strip()
print(new_text) -> Hello, world!
text2 = 'Hello, world!'
new_text2 = text.strip('He')
print(new_text) -> llo, world!

- .split(sep=None, maxsplit=-1)
  - sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환
  - sep을 지정하지 않으면 띄워쓰기를 기준으로 구분함
  - maxsplit에는 구분할 횟수를 지정

text = 'Hello, world!'
words1 = text.split(',')
words2 = text.split()
print(words1) -> ['Hello', ' world!']
print(words2) -> ['Hello,', 'world!']

- 'separator'.join(iterable)
  - iterable의 문자열을 연결한 문자열을 반환
  - separator(구분자)를 앞쪽에 배치해서 구분자가 호출을 하는 형태

words = ['Hello', 'world!']
text = '-'.join(words)
print(text) -> 'Hello-world!'

### 리스트 값 추가 및 삭제 메서드
추가 및 삭제가 원본에 조작됨
`반환값이 없음!`(반환을 하는 소수의 메서드를 제외하면 None이 반환됨)

- .append(x)
  - 리스트 마지막에 항목 x를 추가

my_list = [1, 2, 3]
print(my_list.append(5)) -> None
my_list.append(4)
print(my_list) -> [1, 2, 3, 4]

- .extend(iterable)
  - 리스트에 다른 반복가능한 객체의 모든 항목을 추가
  - 값을 풀어서 요소로 추가함

my_list = [1, 2, 3]
my_list.extend([4, 5, 6])
print(my_list) -> [1, 2, 3, 4, 5, 6]

my_list.append([7, 8, 9])
print(my_list) -> [1, 2, 3, 4, 5, 6, [7, 8, 9]]

- .insert(i, x)
  - 리스트의 지정한 인덱스 i 위치에 항목 x를 삽입

my_list = [1, 2, 3]
my_list.insert(1, 5)
print(my_list) [1, 5, 2, 3]

- .remove(x)
  - 리스트에서 첫 번째로 일치하는 항목을 삭제

my_list = [1, 2, 3, 2, 2, 2]
my_list.remove(2)
print(my_list) ->[1, 3, 2, 2, 2]

- .pop(i)
  - 리스트에서 지정한 인덱스의 항목을 제거하고 `반환`
  - 작성하지 않을 경우 마지막 항목을 제거

my_list = [1, 2, 3, 4, 5]
item1 = my_list.pop()
item2 = my_list.pop(0)
print(item1) -> 5
print(item2) -> 1
print(my_list) -> [2, 3, 4]

- .clear()
  - 리스트의 모든 항목을 삭제

my_list = [1, 2, 3]
my_list.clear()
print(my_list) -> []

### 리스트 탐색 및 정렬 메서드
- .index()
  - 리스트에서 첫 번째로 일치하는 항목 x의 인덱스를 반환

my_list = [1, 2, 3]
index = my_list.index(2)
print(index) -> 1

- .count(x)
  - 리스트에서 항목 x의 개수를 반환

my_list = [1, 2, 2, 3, 3, 3]
count = my_list.count(3)
print(count) -> 3

- .reverse()
  - 리스트의 순서를 역순으로 변경(정렬 x)

my_list = [1, 3, 2, 8, 1, 9]
my_list.reverse()
print(my_list.reverse()) -> None
print(my_list) -> [9, 1, 8, 2, 3, 1]

- .sort()
  - 원본 리스트를 오름차순으로 정렬
  - ()에 reverse=True를 넣으면 내림차순으로 정렬 가능

my_list = [3, 2, 100, 1]
my_list.sort()
print(my_list) -> [1, 2, 3, 100]

my_list.sort(reverse=True)
print(my_list) -> [100, 3, 2, 1]

### 객체와 참조
- 변수 할당
  - 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정임
  - 새로운 객체가 생성되거나, 기존 객체에 대한 참조가 생성

- 가변 객체 예시

a = [1, 2, 3, 4]
b = a
b[0] = 100
print(a) -> [100, 2, 3, 4]
print(b) -> [100, 2, 3, 4]
print(a is b) -> True

- 불변 객체 예시

a = 20
b = a
b = 10
print(a) = 20
print(b) = 10
print(a is b) -> False

- id()함수
  - 객체의 메모리 주소를 확인 가능한 함수
  - is 연산자를 통해 두 변수가 같은 객체를 참조하는지 확인 가능

x = [1, 2, 3]
y = x
z = [1, 2, 3]

print(id(x)) -> 1682231207424
print(id(y)) -> 1682231207424
print(id(z)) -> 1682231224896
print(x is y) -> True
print(x is z) -> False

- 불변 객체/가변 객체의 사용 이유
  - 불변 객체는 여러 변수가 동일한 객체를 안전하게 공유할 수 있음
  - 가변 객체는 내용 수정이 빈번할 때, 대신 기존 객체를 직접 수정가능

### 복사
- 얕은 복사
  - 객체의 최상위 요소만 새로운 메모리에 복사하는 방법
  - 중첩된 객체가 있다면, 그 객체의 참조만 복사됨
  - 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 가변 객체를 수정하면, 원본까지 같이 변경되므로 주의할 것

a = [1, 2, 3]
d = list(a)

a[0] = 100

print(a) -> [100, 2, 3]
print(d) -> [1, 2, 3]

- 얕은 복사의 한계
  - 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 또 있는 경우
  - 최상위 요소만 복사하기 때문에, 내부 객체의 주소는 같아서 함께 변경됨

a = [1, 2, [3, 4, 5]]
b = a[:]

b[0] = 999
print(a) -> [1, 2, [3, 4, 5]]
print(b) -> [999, 2, [3, 4, 5]]

b[2][1] = 100
print(a) -> [1, 2, [3, 100, 5]]
print(b) -> [999, 2, [3, 100, 5]]

print(a[2] is b[2]) -> True

- 얕은 복사에서의 주의점
  - 1차원 리스트에서는 얕은 복사로 충분히 독립적인 복사본을 만들 수 있으나
  - 다차원 리스트에서는 최상위 리스트만 복사되고, 내부 리스트는 여전히 원본과 같은 객체를 참조함

- 깊은 복사
  - 객체의 모든 수준의 요소를 새로운 메모리로 복사하는 방법
  - 중첩된 객체까지 모두 새로운 개체로 생성됨
  - copy모듈의 deepcopy()함수를 사용

import copy

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100

print(a) -> [1, 2, [3, 4, 5]]
print(b) -> [1, 2, [3, 100, 5]]
print(a[2] is b[2]) -> False

### 참고
- List Comprehension
  - 간결하고 효율적인 리스트 생성 방법
  - 코드를 더 '파이썬답게' 작성하는 방법 중 하나
  - 사용 전

numbers = [1, 2, 3, 4, 5]
squared_numbers = []

for num in numbers:
    squared_numbers.append(num**2)

print(squared_numbers) -> [1, 4, 9, 16, 25]

  - 사용 후

numbers = [1, 2, 3, 4, 5]

squared_numbers = [num**2 for num in numbers]
print(squared_numbers) -> [1, 4, 9, 16, 25]

  - [표현식 for 변수 in 순회 가능한 객체 if 조건]의 형태로 사용
  - 인접행렬 생성 식 예시

data1 = [[0] * (5) for _ in range(5)]
또는
data2 = [[0 for _ in range(5)] for _ in range(5)]
->
[[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0],
[0, 0, 0, 0, 0]]

  - 그러나 comprehension을 남용하는 것은 X
    - 가독성이 더 좋은 쪽으로 사용할 것

- 메서드 체이닝
  - 여러 메서드를 연속으로 호출하는 방식

text = 'heLLo, soRld!'
new_text = text.swapcase().replace('l', 'z')
print(new_text) -> HEzzO, WOrLD!

  - text.swapcase(), .replace 순으로 진행됨

numbers = [3, 1, 4, 1, 5, 9, 2]
result = numbers.copy().sort()
print(numbers) -> [3, 1, 4, 1, 5, 9, 2] (원본은 변경되지 않음)
print(result) -> None (sort()는 None을 반환하기 때문)

result = numbers.append(7).extend([8, 9]) -> AttributeError (.append()함수는 None을 반환하기 때문에 Error 발생)

- 문자 유형 판별 메서드
  - isdecimal()
    - 문자열이 모두 숫자문자(0~0)로만 이루어져 있어야 True
  - isdigit()
    - isdecimal()과 비슷하지만, 유니코드 숫자도 인식
  - isnumeric()
    - isdigit()과 비슷하지만, 몇 가지 추가적인 유니코드 문자들을 인식
    - 분수, 지수, 루트 기호도 숫자로 인식함

