### 딕셔너리 메서드
- .get(key[,default])
  - 키와 연결된 값을 반환. 키가 없으면 None 또는 기본값을 반환

person = {'name': 'Alice', 'age': 25}

print(person.get('name')) -> Alice
print(person.get('country')) -> None
print(person.get('country', 'Unknown')) -> Unknown
print(person['country']) -> KeyError: 'country'

  - 딕셔너리는 원래 없는 키를 호출할 시 KeyError이 발생하는데, .get 메서드를 통해 None 혹은 지정된 값을 반환가능

- .keys()
  - 딕셔너리 키를 모은 객체를 반환

person = {'name': 'Alice', 'age': 25}
print(person.keys()) -> dict_keys(['name', 'age'])
for item in person.keys():
    print(item)
->
name
age

  - 실시간으로 동기화되는 키 확인 창이 출력됨

person = {'name': 'Alice', 'age': 25}
person_keys = person.keys()
person('country') = 'KOREA'
print(person_keys) -> dict_keys(['name', 'age', 'country'])

- .values()
  - 딕셔너리 값을 모은 객체를 반환
  - .keys()와 똑같은 형식

person = {'name': 'Alice', 'age': 25}
print(person.values()) -> dict_values(['Alice', 25])
for item in person.values():
    print(item)
->
Alice
25

- .items()
  - 딕셔너리 키/값 쌍을 모은 객체를 반환

person = {'name': 'Alice', 'age': 25}
print(person.items()) -> dict_items([('name', 'Alice'), ('age', 25)])
for key, value in person.items():
    print(key, value)
->
name Alice
age 25

  - .items()는 키/값 쌍을 튜플로 묶은 리스트 형식으로 반환함

- .pop(key[,default])
  - 키를 제거하고 연결됐던 값을 반환(없으면 KeyError이나 default를 반환)
  - 리스트에서와 같이 제거와 반환기능이 있음

person = {'name': 'Alice', 'age': 25}

print(person.pop('age')) -> 25
print(person) -> {'name': 'Alice'}
print(person.pop('country', None)) -> None
print(person.pop('country')) -> KeyError: 'country'

- .clear()
  - 딕셔너리의 모든 키/값 쌍을 제거
  - 리스트에서와 사용법이 같음

person = {'name': 'Alice', 'age': 25}
person.clear()
print(person) -> {}

- .setdefault(key[,default])
  - 키와 연결된 값을 반환
  - 키가 없으면, default와 연결한 키를 딕셔너리에 추가하고 default를 반환
  - .get()와 비교하면 키가 없을 때 default를 반환하는 것 까지는 똑같지만, 딕셔너리에 default와 key를 추가한다는 차이점이 있음

person = {'name': 'Alice', 'age': 25}
print(person.setdefault('country', 'KOREA')) -> KOREA
print(person) -> {'name': 'Alice', 'age': 25, 'country': 'KOREA'}

- .update([other])
  - other가 제공하는 키/값 쌍으로 딕셔너리를 정리하고, 기존 값은 덮어씀

person = {'name': 'Alice', 'age': 25}
other_person = {'name': 'Jane', 'country': 'KOREA'}

person.update(other_person)
print(person) -> {'name': 'Jane', 'age': 25, 'country': 'KOREA'}

person.update(age=100, address='SEOUL')
print(person) -> {'name': 'Jane', 'age': 100, 'country': 'SEOUL'}

### 세트 메서드
- .add(x)
  - 세트에 x를 추가

my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.add('d')
print(my_set) -> {1, 'b', 3, 2, 'c', 'd', 'a'}
my_set.add('d')
print(my_set) -> {1, 'b', 3, 2, 'c', 'd', 'a'}

- .update(itearable)
  - 세트에 다른 iterable 요소를 추가

my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.update([1, 4, 5])
print(my_set) -> {'c', 2, 3, 1, 'b', 4, 5, 'a'}

- .clear()
  - 세트의 모든 항목을 제거

my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.clear()
print(my_set) -> set()

- .remove(x)
  - 세트에서 항목 x를 제거
  - 항목 x가 없을 경우 KeyError

my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.remove(2)
print(my_set) -> {'b', 1, 3, 'c', 'a'}
my_set.remove(10)
print(my_set) -> KeyError: 10

- .pop()
  - 세트에서 `임의의` 요소를 제거하고 반환
    - `임의의`는 무작위는 아님

my_set = {'a', 'b', 'c', 1, 2, 3}

element = my_set.pop()
print(element) -> 1
print(my_set) -> {2, 3, 'b', 'a', 'c'}

  - 위 예시를 여러번 반복하면, 문자열이나 1은 자주 나오는데 2나 3은 거의 나오지 않음.

- .discard(x)
  - 세트 s에서 항목 x를 제거. .remove와 달리 에러가 없음

my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.discard(2)
print(my_set) -> {1, 3, 'a', 'c', 'b'}
my_set.discard(10) -> (출력 x)

- set의 집합 메서드
  - set1.difference(set2) == set1 - set2
  - set1.intersection(set2) == set1 & set2
  - set1.issubset(set2) == set1 <= set2
  - set1.issuperset(set2) == set1 >= set2
  - set1.union(set2) == set1 | set2

### 참고
- 해시 테이블
  - 키(Key)와 값(Value)을 짝지어 저장하는 자료구조
  - 데이터를 고유한 값으로 변환하는 과정을 해시라고 함
  - 생성된 해시 값(고유한 정수)는 해당 데이터를 식별하는 지문 역할을 함
- 해시 함수
  - 임의 길이 데이터를 입력받아 고정길이(정수)로 변환해주는 함수.
  - 이 '정수'가 바로 해시값임
  - 해시함수는 키(Key)를 입력받아 데이터를 저장하거나 찾을 배열의 '정확한 인덱스'를 즉시 계산함
  - 책의 제목(키)을 알면 색인(해시 함수)을 통해 페이지 번호(인덱스)를 바로 알아내고, 이동하여 내용을 찾는 것과 같음
- set의 pop 메서드 예시 - 정수

my_set = {3, 2, 1, 9, 100, 4, 87, 39, 10, 52}
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set)
->
1
2
3
100
4
39
9
10
52
87
set()

  - 해시 함수는 정수를 출력하는데, 버킷의 구조는 실행시마다 동일함
  - 정수(숫자) 값은 해시 값이 숫자 자기 자신과 동일하거나 단순 계산으로 고정됨
- set의 pop 메서드가 문자열에서 해시 계산 시, `해시 난수화`가 적용되어 실행마다 순서가 달라질 수 있음
- 파이썬에서의 해시함수
  - 같은 정수는 항상 같은 해시 값을 가짐
  - 문자열 해시 시, 파이썬 인터프리터 시작 때 설정되는 난수 시드가 달라질 수 있음
    - 보안상 이유로 해시 난수화 도입
  - 문자열 해시는 각 실행마다 달라질 수 있음

print(hash(1)) -> 1
print(hash(1)) -> 1
print(hash('a')) -> 실행시마다 다름
print(hash('a')) -> 실행시마다 다름

- set의 pop()은 '임의의 요소'를 제거하고 반환함
  - 실행할 때마다 다른 요소를 얻는다는 의미인 '무작위'가 아니라,
  - '임의'라는 의미에서의 '무작위'임
    - 버킷 배치 순서가 임의로 지정되었다는 의미
    - 자료구조상 배치순서는 있음

- hashable
  - hash()함수에 넣어 해시 값을 구할 수 있는 객체를 의미
  - int, float, str, tuple 등 대부분의 불변타입은 해시가 가능
  - list, dict, set 등 가변형 객체들은 기본적으로 해시가 불가능
    - 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨지게 됨

- 파이썬 문법 규격
  - EBNF 문법 : 메타 기호를 BNF에서 추가하여 더 간결하고 표현력이 강해진 형태
  - 메타 기호 [] -> 선택적 요소
  - 메타 기호 {} -> 0번 이상 반복
  - 메타 기호 () -> 그룹화
  - 서로 다른 프로그래밍 언어, 데이터 형식, 프로토콜 등의 문법을 통일하여 정의하기 위해 사용
  